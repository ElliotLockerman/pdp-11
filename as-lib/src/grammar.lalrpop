use std::convert::TryInto;

use common::asm::*;
use crate::ir::{Cmd, Stmt};
use crate::helpers::parse_int;
use common::{make_double_operand_ins, make_branch_ins, make_jmp_ins, make_jsr_ins, make_rts_ins, make_misc_ins, make_cc_ins, make_single_operand_ins};

grammar;

R: Reg = {
    "r0" => Reg::R0,
    "r1" => Reg::R1, 
    "r2" => Reg::R2,
    "r3" => Reg::R3,
    "r4" => Reg::R4,
    "r5" => Reg::R5,
    "r6" => Reg::SP,
    "r7" => Reg::PC,

    "sp" => Reg::SP,
    "pc" => Reg::PC,
};

Imm: u16 = {
    <r#"-?\d*\."#> => {
        let s = <>;
        parse_int(&s[..s.len() - 1], 10)
    },
    <r#"-?[0-7]+"#> => parse_int(<>, 8),
};

Label: String = {
    <r#"[a-zA-Z_][a-zA-Z0-9_]*"#> => <>.to_string(),
};
 
RegArg: RegArg = {
    <R> => RegArg::new(AddrMode::Gen, <>, Extra::None),
    "@" <R> => RegArg::new(AddrMode::Def, <>, Extra::None),
    "(" <R> ")" => RegArg::new(AddrMode::Def, <>, Extra::None),
    "(" <R> ")" "+" => RegArg::new(AddrMode::AutoInc, <>, Extra::None),
    "@" "(" <R> ")" "+" => RegArg::new(AddrMode::AutoIncDef, <>, Extra::None),
    "-" "(" <R> ")" => RegArg::new(AddrMode::AutoDec, <>, Extra::None),
    "@" "-" "(" <R> ")" => RegArg::new(AddrMode::AutoDecDef, <>, Extra::None),
    <i:Imm> "(" <r:R> ")" => RegArg::new(AddrMode::Index, r, Extra::Imm(i)),
    "@" <i:Imm> "(" <r:R> ")" => RegArg::new(AddrMode::IndexDef, r, Extra::Imm(i)),

    <Imm> => RegArg::new(AddrMode::Index, Reg::PC, Extra::Rel(<>)),
    "@" <Imm> => RegArg::new(AddrMode::IndexDef, Reg::PC, Extra::Rel(<>)),
    "#" <Imm> => RegArg::new(AddrMode::AutoInc, Reg::PC, Extra::Imm(<>)),
    "@" "#" <Imm> => RegArg::new(AddrMode::AutoIncDef, Reg::PC, Extra::Imm(<>)),

    <Label> => RegArg::new(AddrMode::Index, Reg::PC, Extra::LabelRef(<>)),
    "#" <Label> => RegArg::new(AddrMode::AutoInc, Reg::PC, Extra::LabelRef(<>)),
    "@" <Label> => RegArg::new(AddrMode::IndexDef, Reg::PC, Extra::LabelRef(<>)),
};


I: Ins = {
    "halt" => make_misc_ins!(Halt),

    "mov" <src:RegArg> "," <dst:RegArg> => make_double_operand_ins!(Mov, src, dst),
    "cmp" <src:RegArg> "," <dst:RegArg> => make_double_operand_ins!(Cmp, src, dst),
    "bit" <src:RegArg> "," <dst:RegArg> => make_double_operand_ins!(Bit, src, dst),
    "bic" <src:RegArg> "," <dst:RegArg> => make_double_operand_ins!(Bic, src, dst),
    "bis" <src:RegArg> "," <dst:RegArg> => make_double_operand_ins!(Bis, src, dst),
    "add" <src:RegArg> "," <dst:RegArg> => make_double_operand_ins!(Add, src, dst),

    "movb" <src:RegArg> "," <dst:RegArg> => make_double_operand_ins!(MovB, src, dst),
    "cmpb" <src:RegArg> "," <dst:RegArg> => make_double_operand_ins!(CmpB, src, dst),
    "bitb" <src:RegArg> "," <dst:RegArg> => make_double_operand_ins!(BitB, src, dst),
    "bicb" <src:RegArg> "," <dst:RegArg> => make_double_operand_ins!(BicB, src, dst),
    "bisb" <src:RegArg> "," <dst:RegArg> => make_double_operand_ins!(BisB, src, dst),
    "sub" <src:RegArg> "," <dst:RegArg> => make_double_operand_ins!(Sub, src, dst),

    "br" <Label> => make_branch_ins!(Br, <>),
    "bne" <Label> => make_branch_ins!(Bne, <>),
    "beq" <Label> => make_branch_ins!(Beq, <>),
    "bge" <Label> => make_branch_ins!(Bge, <>),
    "blt" <Label> => make_branch_ins!(Blt, <>),
    "bgt" <Label> => make_branch_ins!(Bgt, <>),
    "ble" <Label> => make_branch_ins!(Ble, <>),

    "bpl" <Label> => make_branch_ins!(Bpl, <>),
    "bmi" <Label> => make_branch_ins!(Bmi, <>),
    "bhi" <Label> => make_branch_ins!(Bhi, <>),
    "bhis" <Label> => make_branch_ins!(Bcc, <>),
    "blo" <Label> => make_branch_ins!(Bcs, <>),
    "blos" <Label> => make_branch_ins!(Blos, <>),
    "bvc" <Label> => make_branch_ins!(Bvc, <>),
    "bvs" <Label> => make_branch_ins!(Bvs, <>),
    "bcc" <Label> => make_branch_ins!(Bcc, <>),
    "bcs" <Label> => make_branch_ins!(Bcs, <>),

    "jmp" <RegArg> => make_jmp_ins!(<>),

    "jsr" <reg:R> "," <dst:RegArg> => make_jsr_ins!(reg, dst),
    "rts" <reg:R>  => make_rts_ins!(reg),

    "clr" <RegArg> => make_single_operand_ins!(Clr, <>),
    "com" <RegArg> => make_single_operand_ins!(Com, <>),
    "inc" <RegArg> => make_single_operand_ins!(Inc, <>),
    "dec" <RegArg> => make_single_operand_ins!(Dec, <>),
    "neg" <RegArg> => make_single_operand_ins!(Neg, <>),
    "adc" <RegArg> => make_single_operand_ins!(Adc, <>),
    "sbc" <RegArg> => make_single_operand_ins!(Sbc, <>),
    "tst" <RegArg> => make_single_operand_ins!(Tst, <>),
    "ror" <RegArg> => make_single_operand_ins!(Ror, <>),
    "rol" <RegArg> => make_single_operand_ins!(Rol, <>),
    "asr" <RegArg> => make_single_operand_ins!(Asr, <>),
    "asl" <RegArg> => make_single_operand_ins!(Asl, <>),
    "swab" <RegArg> => make_single_operand_ins!(Swab, <>),

    "nop" => make_cc_ins!(Nop),
    "clc" => make_cc_ins!(Clc),
    "clv" => make_cc_ins!(Clv),
    "clz" => make_cc_ins!(Clz),
    "cln" => make_cc_ins!(Cln),
    "sec" => make_cc_ins!(Sec),
    "sev" => make_cc_ins!(Sev),
    "sez" => make_cc_ins!(Sez),
    "sen" => make_cc_ins!(Sen),
};


// Doesn't support escapes
StrLiteral = r#""[^"]*""#;

Bytes: Vec<u8> = {
    ".byte" <b:(<Imm>)*> => b.iter().map(|x| TryInto::<u8>::try_into(*x).unwrap()).collect(),
};

Words: Vec<u16> = {
    ".word" <(<Imm>)*> => <>,
};

pub Cmd: Cmd = {
    <Bytes> => Cmd::Bytes(<>),
    <Words> => Cmd::Words(<>),
    ".ascii" <StrLiteral> => {
        let mut v = <>.as_bytes().to_vec();

        // Remove quotes
        v.pop();
        v.remove(0);

        Cmd::Ascii(v)
    },
    ".asciz" <StrLiteral> => {
        let mut v = <>.as_bytes().to_vec();

        // Remove quotes, add nul
        v.remove(0);
        let len = v.len();
        v[len-1] = 0;

        Cmd::Ascii(v)
    },
    <I> => Cmd::Ins(<>),
};

pub Stmt: Stmt = {
    <label_def: Label> ":" => Stmt::new(Some(label_def), None),
    <cmd:Cmd> => Stmt::new(None, Some(cmd)),
    <label_def: Label> ":" <cmd:Cmd> => Stmt::new(Some(label_def), Some(cmd)),
    () => Stmt::new(None, None),
}

match {
    // Skip comments
    r";[^\n\r]*" => { },
} else {
    // Ignore whitespace
    r"\s*" => { },
    _,
}
