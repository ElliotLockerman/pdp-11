use std::convert::TryInto;

use common::asm::*;
use crate::ir::{Cmd, Stmt};
use crate::helpers::parse_int;
use common::{make_double_operand_ins, make_branch_ins, make_jmp_ins, make_jsr_ins, make_rts_ins, make_misc_ins, make_cc_ins, make_single_operand_ins};

grammar;

R: Reg = {
    "r0" => Reg::R0,
    "r1" => Reg::R1, 
    "r2" => Reg::R2,
    "r3" => Reg::R3,
    "r4" => Reg::R4,
    "r5" => Reg::R5,
    "r6" => Reg::SP,
    "r7" => Reg::PC,

    "sp" => Reg::SP,
    "pc" => Reg::PC,
};

Imm: u16 = {
    <r#"-?\d*\."#> => {
        let s = <>;
        parse_int(&s[..s.len() - 1], 10)
    },
    <r#"-?[0-7]+"#> => parse_int(<>, 8),
    <r#"'[!-~]"#> => {
        let s = <>;
        let mut chars = s.chars();
        chars.next().unwrap();
        chars.next().unwrap() as u8 as u16
    },
};

Symbol: String = {
    <r#"[a-zA-Z_][a-zA-Z0-9_]*"#> => <>.to_string(),
};

Expr: Expr = {
    <Imm> => Expr::Val(<>),
    <Symbol> => Expr::SymbolRef(<>),
}

 
RegArg: RegArg = {
    <R> => RegArg::new(AddrMode::Gen, <>, Extra::None),
    "@" <R> => RegArg::new(AddrMode::Def, <>, Extra::None),
    "(" <R> ")" => RegArg::new(AddrMode::Def, <>, Extra::None),
    "(" <R> ")" "+" => RegArg::new(AddrMode::AutoInc, <>, Extra::None),
    "@" "(" <R> ")" "+" => RegArg::new(AddrMode::AutoIncDef, <>, Extra::None),
    "-" "(" <R> ")" => RegArg::new(AddrMode::AutoDec, <>, Extra::None),
    "@" "-" "(" <R> ")" => RegArg::new(AddrMode::AutoDecDef, <>, Extra::None),
    <e:Expr> "(" <r:R> ")" => RegArg::new(AddrMode::Index, r, Extra::Imm(e)),
    "@" <e:Expr> "(" <r:R> ")" => RegArg::new(AddrMode::IndexDef, r, Extra::Imm(e)),

    <Expr> => RegArg::new(AddrMode::Index, Reg::PC, Extra::Rel(<>)),
    "@" <Expr> => RegArg::new(AddrMode::IndexDef, Reg::PC, Extra::Rel(<>)),
    "#" <Expr> => RegArg::new(AddrMode::AutoInc, Reg::PC, Extra::Imm(<>)),
    "@" "#" <Expr> => RegArg::new(AddrMode::AutoIncDef, Reg::PC, Extra::Imm(<>)),
};


I: Ins = {
    "halt" => make_misc_ins!(Halt),

    "mov" <src:RegArg> "," <dst:RegArg> => make_double_operand_ins!(Mov, src, dst),
    "cmp" <src:RegArg> "," <dst:RegArg> => make_double_operand_ins!(Cmp, src, dst),
    "bit" <src:RegArg> "," <dst:RegArg> => make_double_operand_ins!(Bit, src, dst),
    "bic" <src:RegArg> "," <dst:RegArg> => make_double_operand_ins!(Bic, src, dst),
    "bis" <src:RegArg> "," <dst:RegArg> => make_double_operand_ins!(Bis, src, dst),
    "add" <src:RegArg> "," <dst:RegArg> => make_double_operand_ins!(Add, src, dst),

    "movb" <src:RegArg> "," <dst:RegArg> => make_double_operand_ins!(MovB, src, dst),
    "cmpb" <src:RegArg> "," <dst:RegArg> => make_double_operand_ins!(CmpB, src, dst),
    "bitb" <src:RegArg> "," <dst:RegArg> => make_double_operand_ins!(BitB, src, dst),
    "bicb" <src:RegArg> "," <dst:RegArg> => make_double_operand_ins!(BicB, src, dst),
    "bisb" <src:RegArg> "," <dst:RegArg> => make_double_operand_ins!(BisB, src, dst),
    "sub" <src:RegArg> "," <dst:RegArg> => make_double_operand_ins!(Sub, src, dst),

    "br" <Symbol> => make_branch_ins!(Br, <>),
    "bne" <Symbol> => make_branch_ins!(Bne, <>),
    "beq" <Symbol> => make_branch_ins!(Beq, <>),
    "bge" <Symbol> => make_branch_ins!(Bge, <>),
    "blt" <Symbol> => make_branch_ins!(Blt, <>),
    "bgt" <Symbol> => make_branch_ins!(Bgt, <>),
    "ble" <Symbol> => make_branch_ins!(Ble, <>),

    "bpl" <Symbol> => make_branch_ins!(Bpl, <>),
    "bmi" <Symbol> => make_branch_ins!(Bmi, <>),
    "bhi" <Symbol> => make_branch_ins!(Bhi, <>),
    "bhis" <Symbol> => make_branch_ins!(Bcc, <>),
    "blo" <Symbol> => make_branch_ins!(Bcs, <>),
    "blos" <Symbol> => make_branch_ins!(Blos, <>),
    "bvc" <Symbol> => make_branch_ins!(Bvc, <>),
    "bvs" <Symbol> => make_branch_ins!(Bvs, <>),
    "bcc" <Symbol> => make_branch_ins!(Bcc, <>),
    "bcs" <Symbol> => make_branch_ins!(Bcs, <>),

    "jmp" <RegArg> => make_jmp_ins!(<>),

    "jsr" <reg:R> "," <dst:RegArg> => make_jsr_ins!(reg, dst),
    "rts" <reg:R>  => make_rts_ins!(reg),

    "clr" <RegArg> => make_single_operand_ins!(Clr, <>),
    "com" <RegArg> => make_single_operand_ins!(Com, <>),
    "inc" <RegArg> => make_single_operand_ins!(Inc, <>),
    "dec" <RegArg> => make_single_operand_ins!(Dec, <>),
    "neg" <RegArg> => make_single_operand_ins!(Neg, <>),
    "adc" <RegArg> => make_single_operand_ins!(Adc, <>),
    "sbc" <RegArg> => make_single_operand_ins!(Sbc, <>),
    "tst" <RegArg> => make_single_operand_ins!(Tst, <>),
    "ror" <RegArg> => make_single_operand_ins!(Ror, <>),
    "rol" <RegArg> => make_single_operand_ins!(Rol, <>),
    "asr" <RegArg> => make_single_operand_ins!(Asr, <>),
    "asl" <RegArg> => make_single_operand_ins!(Asl, <>),

    "clrb" <RegArg> => make_single_operand_ins!(ClrB, <>),
    "comb" <RegArg> => make_single_operand_ins!(ComB, <>),
    "incb" <RegArg> => make_single_operand_ins!(IncB, <>),
    "decb" <RegArg> => make_single_operand_ins!(DecB, <>),
    "negb" <RegArg> => make_single_operand_ins!(NegB, <>),
    "adcb" <RegArg> => make_single_operand_ins!(AdcB, <>),
    "sbcb" <RegArg> => make_single_operand_ins!(SbcB, <>),
    "tstb" <RegArg> => make_single_operand_ins!(TstB, <>),
    "rorb" <RegArg> => make_single_operand_ins!(RorB, <>),
    "rolb" <RegArg> => make_single_operand_ins!(RolB, <>),
    "asrb" <RegArg> => make_single_operand_ins!(AsrB, <>),
    "aslb" <RegArg> => make_single_operand_ins!(AslB, <>),

    "swab" <RegArg> => make_single_operand_ins!(Swab, <>),

    "nop" => make_cc_ins!(Nop),
    "clc" => make_cc_ins!(Clc),
    "clv" => make_cc_ins!(Clv),
    "clz" => make_cc_ins!(Clz),
    "cln" => make_cc_ins!(Cln),
    "sec" => make_cc_ins!(Sec),
    "sev" => make_cc_ins!(Sev),
    "sez" => make_cc_ins!(Sez),
    "sen" => make_cc_ins!(Sen),
};


// Doesn't support escapes
StrLiteral = r#""[^"]*""#;

Bytes: Vec<u8> = {
    ".byte" <b:(<Imm>)*> => b.iter().map(|x| TryInto::<u8>::try_into(*x).unwrap()).collect(),
};

Words: Vec<u16> = {
    ".word" <(<Imm>)*> => <>,
};

pub Cmd: Cmd = {
    <Bytes> => Cmd::Bytes(<>),
    <Words> => Cmd::Words(<>),
    ".ascii" <StrLiteral> => {
        let mut v = <>.as_bytes().to_vec();

        // Remove quotes
        v.pop();
        v.remove(0);

        Cmd::Ascii(v)
    },
    ".asciz" <StrLiteral> => {
        let mut v = <>.as_bytes().to_vec();

        // Remove quotes, add nul
        v.remove(0);
        let len = v.len();
        v[len-1] = 0;

        Cmd::Ascii(v)
    },
    <I> => Cmd::Ins(<>),

    <s:Symbol> "=" <e:Expr> => Cmd::SymbolDef(s, e),
};

pub Stmt: Stmt = {
    <label_def: Symbol> ":" => Stmt::new(Some(label_def), None),
    <cmd:Cmd> => Stmt::new(None, Some(cmd)),
    <label_def: Symbol> ":" <cmd:Cmd> => Stmt::new(Some(label_def), Some(cmd)),
    () => Stmt::new(None, None),
}

match {
    // Skip comments
    r";[^\n\r]*" => { },
} else {
    // Ignore whitespace
    r"\s*" => { },
    _,
}
